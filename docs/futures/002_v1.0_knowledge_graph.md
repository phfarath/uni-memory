# Knowledge Graph

> **Vers√£o Target:** V1.0
> **Status:** ‚è≥ Pendente
> **Owner:** Unassigned
> **Estimativa:** 120h

---

## Descri√ß√£o

### Problema
Atualmente, mem√≥rias no Aethera Cortex s√£o **"flat"** - armazenadas como texto puro sem estrutura√ß√£o. Isso limita significativamente a capacidade de recall:

**Exemplo do problema:**
```
Mem√≥ria 1: "Jo√£o trabalha no projeto X"
Mem√≥ria 2: "Projeto X usa Python e PostgreSQL"
Mem√≥ria 3: "Jo√£o prefere TypeScript a Python"
```

**Pergunta do usu√°rio:** "Quais tecnologias Jo√£o usa no projeto X?"

**Recall atual (limitado):**
- Busca por similaridade retorna mem√≥rias individuais
- LLM precisa inferir conex√µes manualmente
- N√£o h√° garantia de encontrar todas rela√ß√µes

**O que falta:**
- Estrutura expl√≠cita: `Jo√£o` ‚Üí `works_on` ‚Üí `Projeto X`
- Rela√ß√µes transitivas: `Projeto X` ‚Üí `uses` ‚Üí `Python`
- Queries estruturadas: "SELECT tecnologias WHERE pessoa=Jo√£o AND projeto=X"

### Solu√ß√£o
Implementar um **Knowledge Graph** que extrai e armazena:

1. **Entidades** - Pessoas, projetos, tecnologias, conceitos
2. **Rela√ß√µes** - Conex√µes expl√≠citas entre entidades
3. **Atributos** - Propriedades de cada entidade (JSONB)

**Arquitetura:**
```
Mem√≥ria de texto
    ‚Üì
[NER / LLM Extraction]
    ‚Üì
Entidades: {Jo√£o, Projeto X, Python, PostgreSQL}
    ‚Üì
Rela√ß√µes: {Jo√£o ‚Üí works_on ‚Üí Projeto X, Projeto X ‚Üí uses ‚Üí Python}
    ‚Üì
PostgreSQL (entities + relations tables)
```

**Exemplo do novo fluxo:**
```
Input: "Jo√£o trabalha no projeto X usando Python"

Extra√ß√£o:
- Entidades: [Jo√£o (person), Projeto X (project), Python (technology)]
- Rela√ß√µes: [Jo√£o works_on Projeto X, Projeto X uses Python]

Query: "Quais tecnologias Jo√£o usa no projeto X?"
‚Üí Busca no grafo: Jo√£o ‚Üí works_on ‚Üí Projeto X ‚Üí uses ‚Üí [Python, PostgreSQL]
‚Üí Resposta: "Jo√£o usa Python e PostgreSQL no Projeto X"
```

### Valor
‚úÖ **Queries complexas** - "Quem trabalha em projetos que usam PostgreSQL?"
‚úÖ **Melhor RAG** - Busca por rela√ß√µes sem√¢nticas, n√£o s√≥ similaridade textual
‚úÖ **Visualiza√ß√£o futura** - Frontend pode exibir grafo interativo
‚úÖ **Racioc√≠nio inferencial** - "Se Jo√£o trabalha em X e X usa Python, Jo√£o conhece Python"
‚úÖ **Diferencial competitivo** - Apenas SimpleMem tem feature similar

**ROI Estimado:**
- Precis√£o de recall aumenta 40%
- Suporte a queries 3x mais complexas
- Base para features futuras (recomenda√ß√µes, analytics)

---

## Passos de Implementa√ß√£o

### 1. C√≥digo (80h)

#### 1.1 Database Schema (3h)

- [ ] **Criar tabela `entities`** em `app/main.py:init_db()`:
  ```sql
  CREATE TABLE IF NOT EXISTS entities (
      id SERIAL PRIMARY KEY,
      api_key TEXT REFERENCES api_keys(key),
      entity_type TEXT NOT NULL,  -- 'person', 'project', 'technology', 'concept'
      name TEXT NOT NULL,
      attributes JSONB DEFAULT '{}',
      embedding vector(384),
      created_at TIMESTAMPTZ DEFAULT NOW(),
      updated_at TIMESTAMPTZ DEFAULT NOW(),
      UNIQUE(api_key, entity_type, name)
  );
  ```

- [ ] **Criar tabela `relations`**:
  ```sql
  CREATE TABLE IF NOT EXISTS relations (
      id SERIAL PRIMARY KEY,
      from_entity_id INT REFERENCES entities(id) ON DELETE CASCADE,
      relation_type TEXT NOT NULL,  -- 'works_on', 'uses', 'prefers', 'created_by', 'manages'
      to_entity_id INT REFERENCES entities(id) ON DELETE CASCADE,
      confidence REAL DEFAULT 1.0,  -- 0.0-1.0 (0.8 = 80% confian√ßa)
      metadata JSONB DEFAULT '{}',
      created_at TIMESTAMPTZ DEFAULT NOW(),
      UNIQUE(from_entity_id, relation_type, to_entity_id)
  );
  ```

- [ ] **Criar √≠ndices de performance**:
  ```sql
  CREATE INDEX idx_entities_type_name ON entities(entity_type, name);
  CREATE INDEX idx_entities_embedding ON entities USING ivfflat (embedding vector_cosine_ops);
  CREATE INDEX idx_relations_from ON relations(from_entity_id, relation_type);
  CREATE INDEX idx_relations_to ON relations(to_entity_id);
  CREATE INDEX idx_relations_type ON relations(relation_type);
  ```

#### 1.2 Knowledge Graph Engine (40h)

- [ ] **Criar m√≥dulo `app/knowledge_graph.py`** com classe principal:
  ```python
  from typing import List, Dict, Optional, Tuple
  import re
  import json

  class KnowledgeGraph:
      """
      Motor de Knowledge Graph para Aethera Cortex.

      Respons√°vel por:
      - Extrair entidades de texto (NER ou LLM)
      - Extrair rela√ß√µes entre entidades
      - Queries estruturadas no grafo
      - Pathfinding entre entidades
      """

      def __init__(self):
          self.entity_types = ['person', 'project', 'technology', 'concept']
          self.relation_types = [
              'works_on', 'uses', 'prefers', 'created_by',
              'manages', 'depends_on', 'part_of'
          ]

      def extract_entities(self, content: str, api_key: str) -> List[Dict]:
          """
          Extrai entidades de um texto usando LLM.

          Args:
              content: Texto para extrair entidades
              api_key: API key do usu√°rio (para multi-tenancy)

          Returns:
              Lista de entidades no formato:
              [
                  {"type": "person", "name": "Jo√£o", "attributes": {}},
                  {"type": "project", "name": "Projeto X", "attributes": {}}
              ]
          """
          pass

      def extract_relations(
          self,
          content: str,
          entities: List[Dict]
      ) -> List[Tuple[str, str, str]]:
          """
          Extrai rela√ß√µes entre entidades.

          Args:
              content: Texto original
              entities: Lista de entidades extra√≠das

          Returns:
              Lista de tuplas (from_entity, relation, to_entity):
              [("Jo√£o", "works_on", "Projeto X")]
          """
          pass

      def query_entity(
          self,
          name: str,
          entity_type: str,
          api_key: str
      ) -> Optional[Dict]:
          """
          Busca entidade por nome e tipo.

          Returns:
              {"id": 1, "type": "person", "name": "Jo√£o", "attributes": {...}}
          """
          pass

      def query_relations(
          self,
          entity_id: int,
          direction: str = "both"
      ) -> List[Dict]:
          """
          Busca rela√ß√µes de uma entidade.

          Args:
              entity_id: ID da entidade
              direction: "outgoing", "incoming", ou "both"

          Returns:
              Lista de rela√ß√µes com entidades conectadas
          """
          pass

      def find_path(
          self,
          from_entity: str,
          to_entity: str,
          api_key: str,
          max_depth: int = 3
      ) -> Optional[List[Dict]]:
          """
          Encontra caminho mais curto entre duas entidades (BFS).

          Args:
              from_entity: Nome da entidade origem
              to_entity: Nome da entidade destino
              api_key: API key do usu√°rio
              max_depth: Profundidade m√°xima de busca

          Returns:
              Caminho como lista de n√≥s e arestas:
              [
                  {"entity": "Jo√£o", "relation": "works_on"},
                  {"entity": "Projeto X", "relation": "uses"},
                  {"entity": "Python"}
              ]
          """
          pass
  ```

- [ ] **Implementar `extract_entities()` usando LLM**:
  ```python
  def extract_entities(self, content: str, api_key: str) -> List[Dict]:
      """Extrai entidades usando OpenAI API"""

      # Prompt para LLM
      prompt = f"""
      Analise o texto abaixo e extraia todas as entidades mencionadas.

      Entidades podem ser:
      - person: Pessoas (ex: "Jo√£o", "Maria")
      - project: Projetos ou sistemas (ex: "Projeto X", "Sistema de Vendas")
      - technology: Tecnologias ou ferramentas (ex: "Python", "PostgreSQL")
      - concept: Conceitos ou ideias (ex: "Microservi√ßos", "Design Pattern")

      Retorne JSON no formato:
      [
        {{"type": "person", "name": "Jo√£o"}},
        {{"type": "project", "name": "Projeto X"}}
      ]

      Texto: {content}
      """

      response = requests.post(
          "https://api.openai.com/v1/chat/completions",
          headers={"Authorization": f"Bearer {OPENAI_API_KEY}"},
          json={
              "model": "gpt-3.5-turbo",
              "messages": [{"role": "user", "content": prompt}],
              "temperature": 0.0
          }
      )

      # Parse resposta
      result = response.json()['choices'][0]['message']['content']
      entities = json.loads(result)

      # Salvar entidades no banco
      for entity in entities:
          self._save_entity(entity, api_key)

      return entities
  ```

- [ ] **Implementar `_save_entity()` helper**:
  ```python
  def _save_entity(self, entity: Dict, api_key: str) -> int:
      """
      Salva entidade no banco (insert or update).

      Returns:
          entity_id
      """
      conn = get_db_connection()
      c = conn.cursor()

      # Gerar embedding do nome
      embedding = embed_model.encode([entity['name']])[0].tolist()

      # Upsert (insert ou update se j√° existir)
      c.execute("""
          INSERT INTO entities (api_key, entity_type, name, embedding, attributes)
          VALUES (%s, %s, %s, %s, %s)
          ON CONFLICT (api_key, entity_type, name)
          DO UPDATE SET
              embedding = EXCLUDED.embedding,
              attributes = entities.attributes || EXCLUDED.attributes,
              updated_at = NOW()
          RETURNING id
      """, (
          api_key,
          entity['type'],
          entity['name'],
          embedding,
          json.dumps(entity.get('attributes', {}))
      ))

      entity_id = c.fetchone()[0]
      conn.commit()
      conn.close()

      logger.info(f"[KG] Entidade salva: {entity['name']} (id={entity_id})")
      return entity_id
  ```

- [ ] **Implementar `extract_relations()` usando LLM**:
  ```python
  def extract_relations(
      self,
      content: str,
      entities: List[Dict]
  ) -> List[Tuple[str, str, str]]:
      """Extrai rela√ß√µes entre entidades usando LLM"""

      entity_names = [e['name'] for e in entities]

      prompt = f"""
      Analise o texto e identifique rela√ß√µes entre as entidades mencionadas.

      Entidades: {', '.join(entity_names)}

      Rela√ß√µes poss√≠veis:
      - works_on: pessoa trabalha em projeto
      - uses: projeto/pessoa usa tecnologia
      - prefers: pessoa prefere tecnologia
      - created_by: projeto criado por pessoa
      - manages: pessoa gerencia projeto/pessoa
      - depends_on: projeto depende de tecnologia
      - part_of: conceito √© parte de outro conceito

      Retorne JSON no formato:
      [
        {{"from": "Jo√£o", "relation": "works_on", "to": "Projeto X", "confidence": 0.9}},
        {{"from": "Projeto X", "relation": "uses", "to": "Python", "confidence": 1.0}}
      ]

      Texto: {content}
      """

      response = requests.post(
          "https://api.openai.com/v1/chat/completions",
          headers={"Authorization": f"Bearer {OPENAI_API_KEY}"},
          json={
              "model": "gpt-3.5-turbo",
              "messages": [{"role": "user", "content": prompt}],
              "temperature": 0.0
          }
      )

      result = response.json()['choices'][0]['message']['content']
      relations = json.loads(result)

      return [(r['from'], r['relation'], r['to'], r.get('confidence', 1.0))
              for r in relations]
  ```

- [ ] **Implementar `query_entity()`**:
  ```python
  def query_entity(
      self,
      name: str,
      entity_type: str,
      api_key: str
  ) -> Optional[Dict]:
      """Busca entidade por nome e tipo"""
      conn = get_db_connection()
      c = conn.cursor(cursor_factory=RealDictCursor)

      c.execute("""
          SELECT id, entity_type, name, attributes, created_at, updated_at
          FROM entities
          WHERE api_key = %s AND entity_type = %s AND name ILIKE %s
      """, (api_key, entity_type, f"%{name}%"))

      entity = c.fetchone()
      conn.close()

      return dict(entity) if entity else None
  ```

- [ ] **Implementar `query_relations()`**:
  ```python
  def query_relations(
      self,
      entity_id: int,
      direction: str = "both"
  ) -> List[Dict]:
      """Busca rela√ß√µes de uma entidade"""
      conn = get_db_connection()
      c = conn.cursor(cursor_factory=RealDictCursor)

      if direction == "outgoing":
          query = """
              SELECT r.id, r.relation_type, r.confidence,
                     e.id as related_entity_id,
                     e.name as related_entity_name,
                     e.entity_type as related_entity_type
              FROM relations r
              JOIN entities e ON r.to_entity_id = e.id
              WHERE r.from_entity_id = %s
          """
      elif direction == "incoming":
          query = """
              SELECT r.id, r.relation_type, r.confidence,
                     e.id as related_entity_id,
                     e.name as related_entity_name,
                     e.entity_type as related_entity_type
              FROM relations r
              JOIN entities e ON r.from_entity_id = e.id
              WHERE r.to_entity_id = %s
          """
      else:  # both
          query = """
              SELECT r.id, r.relation_type, r.confidence,
                     e.id as related_entity_id,
                     e.name as related_entity_name,
                     e.entity_type as related_entity_type,
                     'outgoing' as direction
              FROM relations r
              JOIN entities e ON r.to_entity_id = e.id
              WHERE r.from_entity_id = %s

              UNION ALL

              SELECT r.id, r.relation_type, r.confidence,
                     e.id as related_entity_id,
                     e.name as related_entity_name,
                     e.entity_type as related_entity_type,
                     'incoming' as direction
              FROM relations r
              JOIN entities e ON r.from_entity_id = e.id
              WHERE r.to_entity_id = %s
          """
          c.execute(query, (entity_id, entity_id))
          results = c.fetchall()
          conn.close()
          return [dict(r) for r in results]

      c.execute(query, (entity_id,))
      results = c.fetchall()
      conn.close()

      return [dict(r) for r in results]
  ```

- [ ] **Implementar `find_path()` usando BFS**:
  ```python
  from collections import deque

  def find_path(
      self,
      from_entity: str,
      to_entity: str,
      api_key: str,
      max_depth: int = 3
  ) -> Optional[List[Dict]]:
      """Encontra caminho mais curto entre entidades (BFS)"""

      # Buscar IDs das entidades
      from_id = self._get_entity_id(from_entity, api_key)
      to_id = self._get_entity_id(to_entity, api_key)

      if not from_id or not to_id:
          return None

      # BFS
      queue = deque([(from_id, [])])  # (entity_id, path)
      visited = {from_id}

      while queue:
          current_id, path = queue.popleft()

          if len(path) > max_depth:
              continue

          if current_id == to_id:
              return path  # Caminho encontrado!

          # Explorar vizinhos
          relations = self.query_relations(current_id, direction="outgoing")

          for rel in relations:
              next_id = rel['related_entity_id']

              if next_id not in visited:
                  visited.add(next_id)
                  new_path = path + [{
                      'entity': self._get_entity_name(current_id),
                      'relation': rel['relation_type'],
                      'to_entity': rel['related_entity_name']
                  }]
                  queue.append((next_id, new_path))

      return None  # Nenhum caminho encontrado
  ```

#### 1.3 Integration com Memory Trace (10h)

- [ ] **Modificar `add_memory_trace_logic()` para extrair entidades automaticamente**:
  ```python
  def add_memory_trace_logic(session_id: str, role: str, content: str, api_key: str):
      """Persiste mem√≥ria + extrai entidades e rela√ß√µes"""
      try:
          # 1. Gerar embedding (j√° existente)
          vec = embed_model.encode([content])[0].tolist()

          # 2. Salvar mem√≥ria (j√° existente)
          conn = get_db_connection()
          c = conn.cursor()
          ts = time.time()
          c.execute("""
              INSERT INTO memories (session_id, role, content, timestamp, embedding)
              VALUES (%s, %s, %s, %s, %s)
          """, (session_id, role, content, ts, vec))
          conn.commit()
          conn.close()

          # 3. NOVO: Extrair entidades e rela√ß√µes
          if role == "user":  # Apenas para mensagens do usu√°rio
              kg = KnowledgeGraph()
              entities = kg.extract_entities(content, api_key)

              if len(entities) >= 2:  # Precisa de pelo menos 2 entidades
                  relations = kg.extract_relations(content, entities)
                  kg.save_relations(relations, api_key)

          logger.info(f"[MEMORY] Trace + KG persistido.")
      except Exception as e:
          logger.critical(f"[MEMORY] Falha: {e}")
          raise
  ```

#### 1.4 REST API Endpoints (12h)

- [ ] **Adicionar endpoint `GET /v1/entities`**:
  ```python
  @app.get("/v1/entities")
  async def list_entities(
      entity_type: Optional[str] = None,
      limit: int = 50,
      user: dict = Security(verify_api_key)
  ):
      """
      Lista entidades do usu√°rio.

      Query params:
          entity_type: Filtrar por tipo (person, project, technology, concept)
          limit: M√°ximo de entidades (default: 50)

      Returns:
          {"entities": [...], "total": 123}
      """
      conn = get_db_connection()
      c = conn.cursor(cursor_factory=RealDictCursor)

      if entity_type:
          c.execute("""
              SELECT id, entity_type, name, attributes, created_at
              FROM entities
              WHERE api_key = %s AND entity_type = %s
              ORDER BY created_at DESC
              LIMIT %s
          """, (user['key'], entity_type, limit))
      else:
          c.execute("""
              SELECT id, entity_type, name, attributes, created_at
              FROM entities
              WHERE api_key = %s
              ORDER BY created_at DESC
              LIMIT %s
          """, (user['key'], limit))

      entities = c.fetchall()
      conn.close()

      return {
          "entities": [dict(e) for e in entities],
          "total": len(entities)
      }
  ```

- [ ] **Adicionar endpoint `GET /v1/entities/{id}`**:
  ```python
  @app.get("/v1/entities/{entity_id}")
  async def get_entity(
      entity_id: int,
      user: dict = Security(verify_api_key)
  ):
      """Retorna detalhes de uma entidade espec√≠fica"""
      kg = KnowledgeGraph()
      entity = kg.get_entity_by_id(entity_id, user['key'])

      if not entity:
          raise HTTPException(404, "Entidade n√£o encontrada")

      return entity
  ```

- [ ] **Adicionar endpoint `GET /v1/entities/{id}/relations`**:
  ```python
  @app.get("/v1/entities/{entity_id}/relations")
  async def get_entity_relations(
      entity_id: int,
      direction: str = "both",
      user: dict = Security(verify_api_key)
  ):
      """Retorna rela√ß√µes de uma entidade"""
      kg = KnowledgeGraph()
      relations = kg.query_relations(entity_id, direction)

      return {"relations": relations}
  ```

- [ ] **Adicionar endpoint `POST /v1/entities`**:
  ```python
  @app.post("/v1/entities")
  async def create_entity(
      entity_type: str,
      name: str,
      attributes: dict = {},
      user: dict = Security(verify_api_key)
  ):
      """Cria entidade manualmente"""
      kg = KnowledgeGraph()
      entity_id = kg._save_entity({
          'type': entity_type,
          'name': name,
          'attributes': attributes
      }, user['key'])

      return {"id": entity_id, "name": name}
  ```

- [ ] **Adicionar endpoint `DELETE /v1/entities/{id}`**:
  ```python
  @app.delete("/v1/entities/{entity_id}")
  async def delete_entity(
      entity_id: int,
      user: dict = Security(verify_api_key)
  ):
      """Deleta entidade (cascade para rela√ß√µes)"""
      conn = get_db_connection()
      c = conn.cursor()

      c.execute("""
          DELETE FROM entities
          WHERE id = %s AND api_key = %s
      """, (entity_id, user['key']))

      deleted = c.rowcount
      conn.commit()
      conn.close()

      if deleted == 0:
          raise HTTPException(404, "Entidade n√£o encontrada")

      return {"deleted": True}
  ```

#### 1.5 MCP Tools (10h)

- [ ] **Adicionar MCP tool `ask_about_entity`**:
  ```python
  Tool(
      name="ask_about_entity",
      description="Busca informa√ß√µes estruturadas sobre pessoas, projetos ou conceitos no knowledge graph",
      inputSchema={
          "type": "object",
          "properties": {
              "entity_name": {
                  "type": "string",
                  "description": "Nome da entidade a buscar"
              },
              "entity_type": {
                  "type": "string",
                  "enum": ["person", "project", "technology", "concept"],
                  "description": "Tipo da entidade"
              }
          },
          "required": ["entity_name"]
      }
  )
  ```

- [ ] **Implementar handler no `call_tool()`**:
  ```python
  elif name == "ask_about_entity":
      entity_name = arguments["entity_name"]
      entity_type = arguments.get("entity_type")

      kg = KnowledgeGraph()
      entity = kg.query_entity(entity_name, entity_type, api_key)

      if not entity:
          return [TextContent(
              type="text",
              text=f"‚ùå Entidade '{entity_name}' n√£o encontrada"
          )]

      # Buscar rela√ß√µes
      relations = kg.query_relations(entity['id'])

      result = f"üìä **{entity['name']}** ({entity['entity_type']})\n\n"
      result += f"**Rela√ß√µes:**\n"

      for rel in relations[:10]:
          result += f"- {rel['relation_type']} ‚Üí {rel['related_entity_name']}\n"

      return [TextContent(type="text", text=result)]
  ```

- [ ] **Adicionar MCP tool `find_connections`**:
  ```python
  Tool(
      name="find_connections",
      description="Encontra conex√µes entre duas entidades no knowledge graph",
      inputSchema={
          "type": "object",
          "properties": {
              "from_entity": {"type": "string"},
              "to_entity": {"type": "string"},
              "max_depth": {"type": "integer", "default": 3}
          },
          "required": ["from_entity", "to_entity"]
      }
  )
  ```

- [ ] **Implementar handler**:
  ```python
  elif name == "find_connections":
      from_entity = arguments["from_entity"]
      to_entity = arguments["to_entity"]
      max_depth = arguments.get("max_depth", 3)

      kg = KnowledgeGraph()
      path = kg.find_path(from_entity, to_entity, api_key, max_depth)

      if not path:
          return [TextContent(
              type="text",
              text=f"‚ùå Nenhuma conex√£o encontrada entre '{from_entity}' e '{to_entity}'"
          )]

      result = f"üîó **Conex√£o encontrada:**\n\n"
      for step in path:
          result += f"{step['entity']} ‚Üí [{step['relation']}] ‚Üí {step['to_entity']}\n"

      return [TextContent(type="text", text=result)]
  ```

#### 1.6 Enhanced Retrieval (5h)

- [ ] **Modificar `retrieve_context_logic()` para incluir entidades relacionadas**:
  ```python
  def retrieve_context_logic(session_id: str, query: str, api_key: str, limit_k: int = 5):
      """RAG h√≠brido: mem√≥rias + entidades do knowledge graph"""

      # 1. Busca tradicional (j√° existente)
      context_items = []  # short-term + long-term memories

      # 2. NOVO: Buscar entidades relacionadas ao query
      kg = KnowledgeGraph()
      query_entities = kg.extract_entities(query, api_key)

      for entity in query_entities:
          entity_data = kg.query_entity(entity['name'], entity['type'], api_key)

          if entity_data:
              relations = kg.query_relations(entity_data['id'], direction="both")

              # Adicionar contexto estruturado
              context_items.append({
                  "source": "knowledge_graph",
                  "role": "system",
                  "content": f"Entidade '{entity['name']}' ({entity['type']}) tem {len(relations)} rela√ß√µes conhecidas"
              })

      return context_items
  ```

---

### 2. Testes (20h)

- [ ] **Criar `tests/test_knowledge_graph.py`**

- [ ] **Test: Extra√ß√£o de entidades de texto**
- [ ] **Test: Extra√ß√£o de rela√ß√µes**
- [ ] **Test: Query de entidade por nome e tipo**
- [ ] **Test: Buscar rela√ß√µes de uma entidade**
- [ ] **Test: Find path entre duas entidades**
- [ ] **Test: MCP tool `ask_about_entity`**
- [ ] **Test: MCP tool `find_connections`**
- [ ] **Test: Integra√ß√£o com memory trace (auto-extraction)**
- [ ] **Test: REST endpoints CRUD**

---

### 3. Documenta√ß√£o (15h)

- [ ] **Atualizar `ARCHITECTURE.md`**: Adicionar se√ß√£o Knowledge Graph com diagrama ER
- [ ] **Atualizar `AI_INSTRUCTIONS.md`**: Adicionar template para novos entity types
- [ ] **Atualizar `app/README.md`**: Documentar KnowledgeGraph API completa
- [ ] **Atualizar `INLINE_DOCS.md`**: Adicionar docstrings para `extract_entities()` e `extract_relations()`

---

### 4. Infraestrutura (5h)

- [ ] **Migration scripts** para tabelas `entities` e `relations`
- [ ] **Criar √≠ndices** (ivfflat para embeddings)
- [ ] **Configurar cleanup job** para entidades √≥rf√£s

---

## Depend√™ncias

**Nenhuma** - Feature independente, mas beneficia Auto-Capture se implementado antes.

---

## Refer√™ncias

- [SimpleMem Knowledge Graph](https://github.com/aiming-lab/SimpleMem)
- [Neo4j Graph Data Science](https://neo4j.com/docs/graph-data-science/)
- [spaCy NER](https://spacy.io/usage/linguistic-features#named-entities)
- [OpenAI Function Calling](https://platform.openai.com/docs/guides/function-calling)

---

**Vers√£o do documento:** 1.0
**√öltima atualiza√ß√£o:** 2026-02-03
